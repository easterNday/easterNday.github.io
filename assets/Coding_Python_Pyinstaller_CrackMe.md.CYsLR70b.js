import{$ as s,U as a,S as i,at as e}from"./chunks/framework.DgqaZlKJ.js";const E=JSON.parse('{"title":"Pyinstaller 逆向工程","description":"","frontmatter":{},"headers":[],"relativePath":"Coding/Python/Pyinstaller_CrackMe.md","filePath":"Coding/Python/Pyinstaller_CrackMe.md","lastUpdated":1708699596000}'),t={name:"Coding/Python/Pyinstaller_CrackMe.md"},n=e(`<h1 id="pyinstaller-逆向工程" tabindex="-1">Pyinstaller 逆向工程 <a class="header-anchor" href="#pyinstaller-逆向工程" aria-label="Permalink to &quot;Pyinstaller 逆向工程&quot;">​</a></h1><h2 id="pyinstaller-简介" tabindex="-1">Pyinstaller 简介 <a class="header-anchor" href="#pyinstaller-简介" aria-label="Permalink to &quot;Pyinstaller 简介&quot;">​</a></h2><p>Pyinstaller 是一款强大的 Python 应用程序打包工具，它可以将你的 Python 代码转换为独立的可执行文件，无论目标机器是否安装了 Python 环境。尽管 Pyinstaller 提供了一定程度的保护机制，如使用 <code>--key</code> 参数加密 <code>.pyc</code> 文件，但因其开源本质，逆向过程仍然可行且极具研究价值。</p><h2 id="exe-转-pyc" tabindex="-1"><code>exe</code> 转 <code>pyc</code> <a class="header-anchor" href="#exe-转-pyc" aria-label="Permalink to &quot;\`exe\` 转 \`pyc\`&quot;">​</a></h2><h3 id="无-key-参数打包逆向" tabindex="-1">无-key 参数打包逆向 <a class="header-anchor" href="#无-key-参数打包逆向" aria-label="Permalink to &quot;无-key 参数打包逆向&quot;">​</a></h3><p>对于没有使用加密密钥打包的 Pyinstaller 应用，我们通常采用 <code>pyinstxtractor.py</code> 工具来解包 <code>exe</code> 文件。通过该工具，我们可以获得一个包含了原始 <code>.pyc</code> 文件的文件夹。值得注意的是，Pyinstaller 对主函数 <code>.pyc</code> 文件的头部进行了特殊处理，但可通过对比提取出的 <code>struct.pyc</code> 文件中的标准头部来修复主函数 <code>.pyc</code> 文件头，从而实现进一步的逆向分析。</p><h3 id="有-key-参数打包逆向" tabindex="-1">有-key 参数打包逆向 <a class="header-anchor" href="#有-key-参数打包逆向" aria-label="Permalink to &quot;有-key 参数打包逆向&quot;">​</a></h3><p>当应用使用了 <code>--key</code> 参数进行加密时，Pyinstaller 使用 <code>tinyAES</code> 库对 <code>.pyc</code> 文件进行了块加密，每块大小为 16 字节。为了逆向此类加密文件，首先，我们需要了解加密的具体流程，并依据解包得到的 <code>archive.pyc</code> 文件和 <code>crypto_key.pyc</code> 中的加密密钥进行还原。</p><h4 id="方法一-基于源码编写解密脚本" tabindex="-1">方法一：基于源码编写解密脚本 <a class="header-anchor" href="#方法一-基于源码编写解密脚本" aria-label="Permalink to &quot;方法一：基于源码编写解密脚本&quot;">​</a></h4><p>参照 GitHub 上的项目 <a href="https://github.com/extremecoders-re/pyinstxtractor" target="_blank" rel="noreferrer">extremecoders-re/pyinstxtractor</a> 提供的方法，我们首先解包得到相关文件并获取密钥。接着，根据加密算法构造解密类 <code>Cipher</code>，该类利用 tinyAES 库对加密数据进行解密。以下是简化版的解密脚本示例：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#!/usr/bin/env python3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tinyaes</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zlib</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取加密密钥</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;MySup3rS3cr3tK3y&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;utf-8&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 实际中替换为真实密钥</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 读取加密文件并解密</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;baby_core.pyc.encrypted&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;rb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inf, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;baby_core.pyc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;wb&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outf:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    iv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inf.read(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CRYPT_BLOCK_SIZE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cipher </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tinyaes.AES(key, iv)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    plaintext </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 添加原始 .pyc 文件头</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 不同版本的 Python 的文件头不同，请注意替换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outf.write(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\x55\\x0d\\x00\\x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    outf.write(plaintext)</span></span></code></pre></div><p>除此之外，您还可以使用 <a href="https://github.com/pyinstxtractor/pyinstxtractor-ng" target="_blank" rel="noreferrer">pyinstxtractor/pyinstxtractor-ng</a> 项目来直接进行反编译（含解密）。</p><h4 id="方法二-修改-pyinstaller-内置工具" tabindex="-1">方法二：修改 Pyinstaller 内置工具 <a class="header-anchor" href="#方法二-修改-pyinstaller-内置工具" aria-label="Permalink to &quot;方法二：修改 Pyinstaller 内置工具&quot;">​</a></h4><p>另一种方法则是深入 Pyinstaller 自带的 <code>achieve_viewer.py</code> 工具源码。此工具能够浏览和解包已打包的文件。我们发现 <code>get_data</code> 函数在解包过程中使用了 zlib 压缩，而我们需要在其基础上添加解密步骤。通过将解密逻辑整合到 <code>get_data</code> 函数内部，即将 <code>zlib.decompress()</code> 替换为先解密后解压的操作，即可成功解密受保护的 <code>.pyc</code> 文件。最后，将解密后的文件加上正确的 <code>.pyc</code> 头部信息，即可通过反编译工具恢复原始 Python 代码。</p><h2 id="pyc-转-py" tabindex="-1"><code>pyc</code> 转 <code>py</code> <a class="header-anchor" href="#pyc-转-py" aria-label="Permalink to &quot;\`pyc\` 转 \`py\`&quot;">​</a></h2><h3 id="安装-uncompyle6" tabindex="-1">安装 uncompyle6 <a class="header-anchor" href="#安装-uncompyle6" aria-label="Permalink to &quot;安装 uncompyle6&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> uncompyle6</span></span></code></pre></div><h3 id="使用-uncompyle6" tabindex="-1">使用 uncompyle6 <a class="header-anchor" href="#使用-uncompyle6" aria-label="Permalink to &quot;使用 uncompyle6&quot;">​</a></h3><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uncompyle6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> baby_core.pyc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> baby_core.py</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>总结来说，尽管 Pyinstaller 打包带来了部署上的便捷性，但其加密机制并不能完全阻止逆向工程。通过上述两种逆向方法，无论是无密钥打包还是加密打包的 Pyinstaller 应用程序，都有可能被细致地剖析还原。因此，在实际开发中，对于敏感和关键的代码，建议结合更高级的安全策略，如代码混淆等技术，提高逆向难度，增强安全性。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://bbs.kanxue.com/thread-271253.htm#msg_header_h2_1" target="_blank" rel="noreferrer">[原创]Python 逆向——Pyinstaller 逆向</a></li><li><a href="https://github.com/extremecoders-re/pyinstxtractor" target="_blank" rel="noreferrer">extremecoders-re/pyinstxtractor</a></li><li><a href="https://github.com/pyinstxtractor/pyinstxtractor-ng" target="_blank" rel="noreferrer">pyinstxtractor/pyinstxtractor-ng</a></li></ul>`,23),l=[n];function h(p,r,k,o,c,d){return i(),a("div",null,l)}const g=s(t,[["render",h]]);export{E as __pageData,g as default};
